{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AnimalDex Real-time Animal Sighting Sharing and Verification Network Please use the navigation bar above to browse our documentation pages!","title":"AnimalDex"},{"location":"#animaldex","text":"Real-time Animal Sighting Sharing and Verification Network Please use the navigation bar above to browse our documentation pages!","title":"AnimalDex"},{"location":"API%20Routes/","text":"API Routes GET /[GPSCoordinates]/nearby Uses the user's approximate location (heavily rounded for anonymity) and returns a JSON list of all posts within a standard radius of the coordinates. /recent Returns a list of X number of most recently approved images. /[User]/gallery Returns a JSON object that contains a list of the user's posts. /[User]/home Returns a JSON object containing both recently approved images and nearby. /voting Returns a the JSON representing a random image in our system currently being voted on. Has a POST counterpart to recieve that data. /voting/[image ID] Same as /voting except it directly links to the voting of a particular image. POST All POST submissions are verified by login. /submit Recieves the image upload from the user. /voting Recieves a user's votes and suggestions on an image. /settings Allows the user to update an user-specific settings.","title":"API Routes"},{"location":"API%20Routes/#api-routes","text":"","title":"API Routes"},{"location":"API%20Routes/#get","text":"","title":"GET"},{"location":"API%20Routes/#gpscoordinatesnearby","text":"Uses the user's approximate location (heavily rounded for anonymity) and returns a JSON list of all posts within a standard radius of the coordinates.","title":"/[GPSCoordinates]/nearby"},{"location":"API%20Routes/#recent","text":"Returns a list of X number of most recently approved images.","title":"/recent"},{"location":"API%20Routes/#usergallery","text":"Returns a JSON object that contains a list of the user's posts.","title":"/[User]/gallery"},{"location":"API%20Routes/#userhome","text":"Returns a JSON object containing both recently approved images and nearby.","title":"/[User]/home"},{"location":"API%20Routes/#voting","text":"Returns a the JSON representing a random image in our system currently being voted on. Has a POST counterpart to recieve that data.","title":"/voting"},{"location":"API%20Routes/#votingimage-id","text":"Same as /voting except it directly links to the voting of a particular image.","title":"/voting/[image ID]"},{"location":"API%20Routes/#post","text":"All POST submissions are verified by login.","title":"POST"},{"location":"API%20Routes/#submit","text":"Recieves the image upload from the user.","title":"/submit"},{"location":"API%20Routes/#voting_1","text":"Recieves a user's votes and suggestions on an image.","title":"/voting"},{"location":"API%20Routes/#settings","text":"Allows the user to update an user-specific settings.","title":"/settings"},{"location":"Team%20Process/CodingGuidelines/","text":"Coding Guidelines Main Branch Write Protections We use main branch protection to avoid accidentally sending experimental code to production. When working on code, please base your feature branch off of dev , and when you're ready to submit, pull any updates from dev and create a pull request. The rest of the team will review the pull request and if it's acceptable will approve and merge it into dev . main will be updated from dev whenever there is a need to update the production version of the site. Feature Branching We will use feature branching to isolate distinct segments to ensure they do not interfere with the primary deployment of the app or with other features in development. To the developers; this means when you set out on a card, you'll need to create a new branch with a reasonably identifyable name relating to the card. When you clone the repo, be sure to switch to that branch and work within it. When you are done, or periodically throughout your work. Be sure to git pull in both your feature branch and the main branch to keep them up to date. You'll need to pull in updates made in main. In your feature branch (not main!) use git merge main to merge in changes from main. This may create some git conflicts; but these are easy enough to resolve. Your IDE will usually be able to highlight them for you; just pick what looks like the most up to date versions. Once you are finished and you've updated your branch to the changes in main: go to your branch on GitHub and create a pull request. This will allow the rest of the team, especially the Coding Lead and Cybersecurity Lead to verify your code is valid and doesn't cause any immediate security vulnerabilities. Once the team approves your feature it will be merged into Main! Documentation Principles To ensure our software is maintainable and reusable, documentation of our code is a requirement. All non-emergency code merged into the main branch of our primary repo should have relevant in-line documentation. It is the developer who is submitting the code to repo's responsiblity to write the appropriate documentation. API Documentation Much of our chosen languages have documentation generating comment syntax. This should be used whenever available. Web Based Documentation Non-in-code documentation should be written on this documentation site.","title":"Coding Guidelines"},{"location":"Team%20Process/CodingGuidelines/#coding-guidelines","text":"","title":"Coding Guidelines"},{"location":"Team%20Process/CodingGuidelines/#main-branch-write-protections","text":"We use main branch protection to avoid accidentally sending experimental code to production. When working on code, please base your feature branch off of dev , and when you're ready to submit, pull any updates from dev and create a pull request. The rest of the team will review the pull request and if it's acceptable will approve and merge it into dev . main will be updated from dev whenever there is a need to update the production version of the site.","title":"Main Branch Write Protections"},{"location":"Team%20Process/CodingGuidelines/#feature-branching","text":"We will use feature branching to isolate distinct segments to ensure they do not interfere with the primary deployment of the app or with other features in development. To the developers; this means when you set out on a card, you'll need to create a new branch with a reasonably identifyable name relating to the card. When you clone the repo, be sure to switch to that branch and work within it. When you are done, or periodically throughout your work. Be sure to git pull in both your feature branch and the main branch to keep them up to date. You'll need to pull in updates made in main. In your feature branch (not main!) use git merge main to merge in changes from main. This may create some git conflicts; but these are easy enough to resolve. Your IDE will usually be able to highlight them for you; just pick what looks like the most up to date versions. Once you are finished and you've updated your branch to the changes in main: go to your branch on GitHub and create a pull request. This will allow the rest of the team, especially the Coding Lead and Cybersecurity Lead to verify your code is valid and doesn't cause any immediate security vulnerabilities. Once the team approves your feature it will be merged into Main!","title":"Feature Branching"},{"location":"Team%20Process/CodingGuidelines/#documentation-principles","text":"To ensure our software is maintainable and reusable, documentation of our code is a requirement. All non-emergency code merged into the main branch of our primary repo should have relevant in-line documentation. It is the developer who is submitting the code to repo's responsiblity to write the appropriate documentation.","title":"Documentation Principles"},{"location":"Team%20Process/CodingGuidelines/#api-documentation","text":"Much of our chosen languages have documentation generating comment syntax. This should be used whenever available.","title":"API Documentation"},{"location":"Team%20Process/CodingGuidelines/#web-based-documentation","text":"Non-in-code documentation should be written on this documentation site.","title":"Web Based Documentation"},{"location":"Team%20Process/Maintaining%20Documentation/","text":"Maintaining Documentation All documentation directly relating to the APIs and specifics should use in-code API documentation wherever applicable; everything else should be documented here. If you've been tasked with researching something, It's likely you'll need to write about it here. Maintanance Instructions To add new pages simply create a new plain text file with a .md file extension somewhere in the /docs directory. Most modern IDEs will be able to parse .md files easily. You'll write your pages in Markdown a simplified text formatting language. Any modern IDE or enhanced text editor will usually be able to highlight markdown just fine, VSCode is a good reccomendation. Once you're done simply commit your files to the repo using git, and a GitHubAction will automatically regenerate and redeploy the website for you, that's it! If you'd like to work with someone on a page but not commit to the web every push, you can create a separate branch to isolate it from the autodeployment, but this is not neccessary. Entirely Optional Installation of MKDocs If you'd like to have a live preview or be able to push directly to the live web version, you'll need to install MKDocs. Make sure you have a relatively modern version of python and the pip package manager installed, then install mkdocs using pip install mkdocs . If you're on windows you may need to use python -m in front of your commands to get them to run with the correct permissions. Once that's done you should be able to use all the mkdocs commands listed below or on the official mkdocs documentation . General MKDocs Documentation mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Maintaining Documentation"},{"location":"Team%20Process/Maintaining%20Documentation/#maintaining-documentation","text":"All documentation directly relating to the APIs and specifics should use in-code API documentation wherever applicable; everything else should be documented here. If you've been tasked with researching something, It's likely you'll need to write about it here.","title":"Maintaining Documentation"},{"location":"Team%20Process/Maintaining%20Documentation/#maintanance-instructions","text":"To add new pages simply create a new plain text file with a .md file extension somewhere in the /docs directory. Most modern IDEs will be able to parse .md files easily. You'll write your pages in Markdown a simplified text formatting language. Any modern IDE or enhanced text editor will usually be able to highlight markdown just fine, VSCode is a good reccomendation. Once you're done simply commit your files to the repo using git, and a GitHubAction will automatically regenerate and redeploy the website for you, that's it! If you'd like to work with someone on a page but not commit to the web every push, you can create a separate branch to isolate it from the autodeployment, but this is not neccessary.","title":"Maintanance Instructions"},{"location":"Team%20Process/Maintaining%20Documentation/#entirely-optional-installation-of-mkdocs","text":"If you'd like to have a live preview or be able to push directly to the live web version, you'll need to install MKDocs. Make sure you have a relatively modern version of python and the pip package manager installed, then install mkdocs using pip install mkdocs . If you're on windows you may need to use python -m in front of your commands to get them to run with the correct permissions. Once that's done you should be able to use all the mkdocs commands listed below or on the official mkdocs documentation .","title":"Entirely Optional Installation of MKDocs"},{"location":"Team%20Process/Maintaining%20Documentation/#general-mkdocs-documentation","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"General MKDocs Documentation"},{"location":"Team%20Process/Maintaining%20Documentation/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Team%20Process/ProjectBacklog/","text":"Project Backlog User Stories It is the job of the Product Owner and Scrum Master to manage the product backlog. Team members will be directly assigned to (usually) one story at a time, and will be responsible for completing it's tasks in a timely manner. Team members need to pay attention to their assigned user stories and be mindful of how they work with eachother. Some stories may be dependent on others, so team members should be aware of time constraints and strive to complete dependancy tasks as soon as possible. Acceptance Criteria Acceptance criteria are simple rules or targets to hit in relation to each card. They are meant to be milestones in that tasks completion and need to be met in order for a task to be considered done. If you think an acceptance criteria doesn't apply or need more clarification please reach out to the Team Lead. Tags Critical Security Story This story represents any security related story, bugfix, or feature that needs to be fixed ASAP. Our Cybersecurity Lead can create and schedule these as needed. Functional Functional user stories implement tangible features in the product. They are often immediately usable. Nonfunctional This user story does not provide any immediate features but instead provides other utilities. This can often simply be updating the documentation, configuring a tool, or performing research.","title":"Project Backlog"},{"location":"Team%20Process/ProjectBacklog/#project-backlog","text":"","title":"Project Backlog"},{"location":"Team%20Process/ProjectBacklog/#user-stories","text":"It is the job of the Product Owner and Scrum Master to manage the product backlog. Team members will be directly assigned to (usually) one story at a time, and will be responsible for completing it's tasks in a timely manner. Team members need to pay attention to their assigned user stories and be mindful of how they work with eachother. Some stories may be dependent on others, so team members should be aware of time constraints and strive to complete dependancy tasks as soon as possible.","title":"User Stories"},{"location":"Team%20Process/ProjectBacklog/#acceptance-criteria","text":"Acceptance criteria are simple rules or targets to hit in relation to each card. They are meant to be milestones in that tasks completion and need to be met in order for a task to be considered done. If you think an acceptance criteria doesn't apply or need more clarification please reach out to the Team Lead.","title":"Acceptance Criteria"},{"location":"Team%20Process/ProjectBacklog/#tags","text":"","title":"Tags"},{"location":"Team%20Process/ProjectBacklog/#critical-security-story","text":"This story represents any security related story, bugfix, or feature that needs to be fixed ASAP. Our Cybersecurity Lead can create and schedule these as needed.","title":"Critical Security Story"},{"location":"Team%20Process/ProjectBacklog/#functional","text":"Functional user stories implement tangible features in the product. They are often immediately usable.","title":"Functional"},{"location":"Team%20Process/ProjectBacklog/#nonfunctional","text":"This user story does not provide any immediate features but instead provides other utilities. This can often simply be updating the documentation, configuring a tool, or performing research.","title":"Nonfunctional"},{"location":"Team%20Process/Tests/","text":"Running Tests locally In order to run tests locally on your machine, pull a branch which contains tests from the repository. To run tests on the Server, navigate to the server directory and on the terminal, run the command \"dotnet test\", which will run the tests using XUnit and output the results of the tests. To run tests on the Client, navigate to the client directory and on the terminal, run the command \"npm test\", which will run the tests using Jest and output the results of the tests. If further updates to testing frameworks require different instructions for running the tests locally, this document will be updated.","title":"Tests"},{"location":"Team%20Process/Tests/#running-tests-locally","text":"In order to run tests locally on your machine, pull a branch which contains tests from the repository. To run tests on the Server, navigate to the server directory and on the terminal, run the command \"dotnet test\", which will run the tests using XUnit and output the results of the tests. To run tests on the Client, navigate to the client directory and on the terminal, run the command \"npm test\", which will run the tests using Jest and output the results of the tests. If further updates to testing frameworks require different instructions for running the tests locally, this document will be updated.","title":"Running Tests locally"}]}